<!DOCTYPE html>
<html>
<head>
    <style>
        html, body, canvas {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            image-rendering: pixelated;
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
<script>
    function Parameters() {
        this.damping = 0.95;
        this.checkerSize = 20;
        this.refractionStrength = 2;
        this.causticStrength = 0.2;
        this.increase = 30;
        this.radius = 10;
        this.height = 50;
    }

    let params = new Parameters();
    let gui = new dat.GUI();
    gui.add(params, 'damping', 0.1, 1.0);
    gui.add(params, 'checkerSize', 2, 50);
    gui.add(params, 'refractionStrength', 0, 2);
    gui.add(params, 'causticStrength', 0, 2);
    gui.add(params, 'increase', 0, 100);
    gui.add(params, 'radius', 1, 100, 1);
    gui.add(params, 'height', 1, 100);

    const canvas = document.getElementById('canvas');
    canvas.width = 256;  // size of simulation grid
    canvas.height = 192;
    canvas.style.width = '100%';  // scale to fill screen
    canvas.style.height = '100%';
    const ctx = canvas.getContext('2d');
    const imageDataCopy = ctx.getImageData(0, 0, canvas.width, canvas.height);

    let grid = new Array(canvas.width).fill(0).map(() => new Array(canvas.height).fill(0));
    let grid2 = new Array(canvas.width).fill(0).map(() => new Array(canvas.height).fill(0));

        function propagate() {
            let damping = params.damping
            for (let x = 1; x < canvas.width - 1; x++) {
                for (let y = 1; y < canvas.height - 1; y++) {
                    let waveHeight = (
                        grid[x - 1][y] +
                        grid[x + 1][y] +
                        grid[x][y - 1] +
                        grid[x][y + 1]
                    ) / 2 - grid2[x][y];
                    waveHeight = waveHeight * damping;
                    grid2[x][y] = waveHeight;
                }
            }
            let temp = grid;
            grid = grid2;
            grid2 = temp;
        }

        function drawBackground() {
            const checkerSize = params.checkerSize;  // size of each square in the checker pattern
            ctx.fillStyle = '#66b3ff'; // saturated light blue
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#3399ff'; // slightly darker saturated light blue
            for (let x = 0; x < canvas.width; x += checkerSize * 2) {
                for (let y = 0; y < canvas.height; y += checkerSize * 2) {
                    ctx.fillRect(x, y, checkerSize, checkerSize);
                }
            }
            for (let x = checkerSize; x < canvas.width; x += checkerSize * 2) {
                for (let y = checkerSize; y < canvas.height; y += checkerSize * 2) {
                    ctx.fillRect(x, y, checkerSize, checkerSize);
                }
            }
        }

        function draw() {
            const refractionStrength = params.refractionStrength;
            const causticStrength = params.causticStrength;

            drawBackground();

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            imageDataCopy.data.set(imageData.data);
            let readImageData = imageData;
            let writeImageData = imageDataCopy;

            // first pass to compute the caustics
            {
                const readData = readImageData.data;
                const writeData = writeImageData.data;
                for (let x = 3; x < canvas.width - 3; x++) {
                    for (let y = 3; y < canvas.height - 3; y++) {
                        let dx = (grid[x - 3][y] + grid[x - 2][y] + grid[x - 1][y]) / 3 - (grid[x + 1][y] + grid[x + 2][y] + grid[x + 3][y]) / 3;
                        let dy = (grid[x][y - 3] + grid[x][y - 2] + grid[x][y - 1]) / 3 - (grid[x][y + 1] + grid[x][y + 2] + grid[x][y + 3]) / 3;

                        let offsetX = x + dx * causticStrength;
                        let offsetY = y + dy * causticStrength;
                        let offsetPos = (Math.floor(offsetY) * canvas.width + Math.floor(offsetX)) * 4;

                        // Bilinear interpolation weights
                        let weightX = offsetX - Math.floor(offsetX);
                        let weightY = offsetY - Math.floor(offsetY);

                        // Increase brightness at the 4 surrounding integer positions
                        let increase = params.increase;  // Change this to adjust the brightness increase
                        for (let i = 0; i <= 1; i++) {
                            for (let j = 0; j <= 1; j++) {
                                let currentPos = ((Math.floor(offsetY) + i) * canvas.width + Math.floor(offsetX) + j) * 4;
                                let weight = (1 - Math.abs(i - weightY)) * (1 - Math.abs(j - weightX));
                                writeData[currentPos] = Math.min(255, writeData[currentPos] + increase * weight);
                                writeData[currentPos + 1] = Math.min(255, writeData[currentPos + 1] + increase * weight);
                                writeData[currentPos + 2] = Math.min(255, writeData[currentPos + 2] + increase * weight);
                            }
                        }
                    }
                }
            }

            // swap buffers
            {
                const temp = readImageData;
                readImageData = writeImageData;
                writeImageData = temp;
            }

            // second pass to compute the refracted image
            {
                const readData = readImageData.data;
                const writeData = writeImageData.data;
                for (let x = 3; x < canvas.width - 3; x++) {
                    for (let y = 3; y < canvas.height - 3; y++) {
                        let dx = (grid[x - 3][y] + grid[x - 2][y] + grid[x - 1][y]) / 3 - (grid[x + 1][y] + grid[x + 2][y] + grid[x + 3][y]) / 3;
                        let dy = (grid[x][y - 3] + grid[x][y - 2] + grid[x][y - 1]) / 3 - (grid[x][y + 1] + grid[x][y + 2] + grid[x][y + 3]) / 3;

                        let refX = x - dx * refractionStrength;
                        let refY = y - dy * refractionStrength;
                        refX = Math.min(canvas.width - 1, Math.max(0, refX));
                        refY = Math.min(canvas.height - 1, Math.max(0, refY));
                        let displacement = (Math.floor(refY) * canvas.width + Math.floor(refX)) * 4;
                        let originalPos = (y * canvas.width + x) * 4;
                        writeData[originalPos] = readData[displacement];
                        writeData[originalPos + 1] = readData[displacement + 1];
                        writeData[originalPos + 2] = readData[displacement + 2];
                        writeData[originalPos + 3] = 255; // Make sure the alpha channel is fully opaque
                    }
                }
            }

            ctx.putImageData(writeImageData, 0, 0);
        }

        function animate() {
            requestAnimationFrame(animate);
            propagate();
            draw();
        }

        canvas.addEventListener('mousemove', function (event) {
            if (event.buttons == 1) {
                let rect = canvas.getBoundingClientRect();
                let scaleX = canvas.width / rect.width;
                let scaleY = canvas.height / rect.height;
                let canvasX = Math.floor((event.clientX - rect.left) * scaleX);
                let canvasY = Math.floor((event.clientY - rect.top) * scaleY);

                let radius = params.radius;  // change this to change the size of the circle around the mouse pointer
                for (let x = Math.max(0, canvasX - radius); x < Math.min(canvas.width, canvasX + radius); x++) {
                    for (let y = Math.max(0, canvasY - radius); y < Math.min(canvas.height, canvasY + radius); y++) {
                        let distanceFromPointer = Math.hypot(x - canvasX, y - canvasY);
                        if (distanceFromPointer <= radius) {
                            let height = params.height * (1 - distanceFromPointer / radius);
                            grid[x][y] = Math.max(grid[x][y], height);
                        }
                    }
                }
            }
        });

        animate();
    </script>
</body>
</html>